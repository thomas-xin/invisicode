<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Invisicode Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
	color-scheme: light dark;
	font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
	background: #f5f5f5;
	color: #222;
}
body {
	margin: 0;
	min-height: 100vh;
	display: flex;
	flex-direction: column;
}
main {
	flex: 1;
	padding: 1.5rem;
	max-width: 960px;
	margin: 0 auto;
}
h1 {
	font-size: 1.9rem;
	margin: 0 0 0.75rem;
}
p.intro {
	margin: 0 0 1.5rem;
	max-width: 720px;
}
.controls {
	display: grid;
	gap: 1.5rem;
	grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}
.panel {
	background: rgba(255, 255, 255, 0.8);
	border: 1px solid #d0d0d0;
	border-radius: 12px;
	padding: 1rem;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
}
.panel h2 {
	font-size: 1.2rem;
	margin: 0 0 0.5rem;
}
label {
	display: block;
	font-weight: 600;
	margin-bottom: 0.5rem;
}

select, textarea, button {
	width: 100%;
	box-sizing: border-box;
	font: inherit;
}
textarea {
	min-height: 180px;
	padding: 0.75rem;
	border-radius: 8px;
	border: 1px solid #c0c0c0;
	resize: vertical;
}
input[type="file"] {
	width: 100%;
	box-sizing: border-box;
	font: inherit;
	padding: 0.4rem 0.5rem;
}
button {
	margin-top: 0.75rem;
	padding: 0.6rem 0.8rem;
	border-radius: 8px;
	border: none;
	background: #1f7aec;
	color: #fff;
	cursor: pointer;
	font-weight: 600;
}
button:disabled {
	background: #a0a0a0;
	cursor: not-allowed;
}
.status {
	margin-top: 1.25rem;
	padding: 0.75rem 1rem;
	border-radius: 8px;
	background: rgba(0, 128, 0, 0.08);
	border: 1px solid rgba(0, 128, 0, 0.2);
}
.status.error {
	background: rgba(196, 24, 24, 0.08);
	border-color: rgba(196, 24, 24, 0.4);
	color: #a00000;
}
.summary {
	margin-top: 0.75rem;
	font-size: 0.95rem;
	line-height: 1.5;
}
.file-info {
	margin-top: 0.5rem;
	font-size: 0.9rem;
	color: #555;
}
.preview-label {
	margin-bottom: 0.5rem;
	font-size: 0.95rem;
	font-weight: 600;
}
.image-preview {
	margin-top: 1rem;
	padding: 0.5rem;
	border-radius: 8px;
	border: 1px solid #c0c0c0;
	background: #fdfdfd;
}
.image-preview img {
	display: block;
	width: 100%;
	max-height: 260px;
	object-fit: contain;
	border-radius: 4px;
	background: #fff;
}
.hidden {
	display: none !important;
}
@media (prefers-color-scheme: dark) {
	:root {
		background: #111;
		color: #f5f5f5;
	}
	.panel {
		background: rgba(24, 24, 24, 0.8);
		border-color: #2f2f2f;
	}
	textarea {
		border-color: #333;
		background: #1c1c1c;
		color: inherit;
	}
	.file-info {
		color: #bbb;
	}
	.image-preview {
		border-color: #2f2f2f;
		background: rgba(40, 40, 40, 0.95);
	}
	.image-preview img {
		background: #1a1a1a;
	}
	.status {
		background: rgba(56, 142, 60, 0.18);
		border-color: rgba(76, 175, 80, 0.45);
	}
	.status.error {
		background: rgba(244, 67, 54, 0.15);
		border-color: rgba(229, 57, 53, 0.45);
	}
}
</style>
</head>
<body>
<main>
	<h1>Invisicode Playground</h1>
	<p class="intro">Paste text or upload a file on the left and generate an invisible Unicode payload, or drop invisicode text on the right to recover the original data. The JavaScript below was generated by GPT-5-Codex, and mirrors the <a href="https://github.com/thomas-xin/invisicode">invisicode</a> reference implementation.</p>
	<div class="controls">
		<section class="panel">
			<h2>Plain Data</h2>
			<label for="plain-mode">Input mode</label>
			<select id="plain-mode">
				<option value="text">Text (LEB128 wrapped)</option>
				<option value="file">Binary file</option>
			</select>
			<label id="plain-text-label" for="plain-input">Content</label>
			<textarea id="plain-input" placeholder="Hello World! ❤️" autocomplete="off"></textarea>
			<label id="plain-file-label" for="plain-file" class="hidden">Select file</label>
			<input id="plain-file" type="file" class="hidden">
			<div id="file-info" class="file-info hidden">No file selected.</div>
			<button id="encode-btn" type="button">Encode →</button>
			<button id="download-btn" type="button" disabled>Download Binary</button>
			<div id="download-info" class="file-info">No decoded file available.</div>
			<div id="image-preview-wrapper" class="image-preview hidden">
				<div class="preview-label">Image preview</div>
				<img id="image-preview" alt="Image preview">
			</div>
		</section>
		<section class="panel">
			<h2>Invisicode String</h2>
			<label for="encoded-output">Payload (invisible characters)</label>
			<textarea id="encoded-output" placeholder="Output appears blank but contains high-plane characters." autocomplete="off"></textarea>
			<button id="decode-btn" type="button">← Decode</button>
			<button id="copy-btn" type="button">Copy Payload</button>
		</section>
	</div>
	<div id="status" class="status" hidden>Ready.</div>
	<div id="summary" class="summary"></div>
</main>
<script>
const BASE = 0xe0000;
const RANGE = 0x1000;
const STRING_PREFIX = 0x1d17a;
const PADDING = BASE + RANGE - 1;

function leb128Encode(str) {
	if (!str) {
		return new Uint8Array(0);
	}
	const bytes = [];
	for (const char of str) {
		const code = char.codePointAt(0);
		if (code < 0x80) {
			bytes.push(code);
		} else if (code < 0x4000) {
			bytes.push((code & 0x7f) | 0x80);
			bytes.push((code >> 7) & 0x7f);
		} else {
			bytes.push((code & 0x7f) | 0x80);
			bytes.push(((code >> 7) & 0x7f) | 0x80);
			bytes.push(code >> 14);
		}
	}
	return new Uint8Array(bytes);
}

function leb128Decode(bytes) {
	const codepoints = [];
	for (let i = 0; i < bytes.length;) {
		const first = bytes[i++];
		if ((first & 0x80) === 0) {
			codepoints.push(first);
			continue;
		}
		if (i >= bytes.length) {
			throw new Error("Incomplete LEB128 sequence.");
		}
		const second = bytes[i++];
		if ((second & 0x80) === 0) {
			const cp = (first & 0x7f) | (second << 7);
			codepoints.push(cp);
			continue;
		}
		if (i >= bytes.length) {
			throw new Error("Incomplete LEB128 sequence.");
		}
		const third = bytes[i++];
		const cp = (first & 0x7f) | ((second & 0x7f) << 7) | (third << 14);
		if (cp >= 0x110000) {
			throw new Error("Decoded codepoint is out of range.");
		}
		codepoints.push(cp);
	}
	let result = "";
	for (const cp of codepoints) {
		result += String.fromCodePoint(cp);
	}
	return result;
}

function encodeInvisicode(dataBytes, treatAsString) {
	let payload = dataBytes;
	let prefix = "";
	if (treatAsString) {
		payload = leb128Encode(dataBytes);
		prefix = String.fromCodePoint(STRING_PREFIX);
	}
		const remainder = payload.length % 3;
		const full = payload.length - remainder;
		const pieces = [];
	for (let i = 0; i < full; i += 3) {
		const chunk = payload[i] | (payload[i + 1] << 8) | (payload[i + 2] << 16);
		const low = chunk & (RANGE - 1);
		const high = chunk >>> 12;
		pieces.push(String.fromCodePoint(BASE | low));
		pieces.push(String.fromCodePoint(BASE | high));
	}
	let suffix = "";
	if (remainder === 1) {
		suffix = String.fromCodePoint(BASE | payload[full]);
	} else if (remainder === 2) {
		suffix = String.fromCodePoint(BASE | payload[full]) +
			String.fromCodePoint(BASE | payload[full + 1]) +
			String.fromCodePoint(PADDING);
	}
	return prefix + pieces.join("") + suffix;
}

function decodeInvisicode(text) {
	const codepoints = [];
	for (const char of text) {
		codepoints.push(char.codePointAt(0));
	}
	let isString = false;
	if (codepoints.length && codepoints[0] === STRING_PREFIX) {
		isString = true;
		codepoints.shift();
	}
	while (codepoints.length && (codepoints[codepoints.length - 1] < BASE || codepoints[codepoints.length - 1] >= BASE + RANGE)) {
		codepoints.pop();
	}
	let suffix = [];
	if (codepoints.length % 2 === 1) {
		if (codepoints.length >= 3 && codepoints[codepoints.length - 1] === PADDING) {
			const first = codepoints[codepoints.length - 2];
			const second = codepoints[codepoints.length - 3];
			suffix = [second - BASE, first - BASE];
			codepoints.length -= 3;
		} else {
			const last = codepoints.pop();
			suffix = [last - BASE];
		}
	}
	const bytes = [];
	for (let i = 0; i < codepoints.length; i += 2) {
		const low = codepoints[i] - BASE;
		const high = codepoints[i + 1] - BASE;
		if (low < 0 || low >= RANGE || high < 0 || high >= RANGE) {
			throw new Error("Character outside invisicode range detected.");
		}
		const chunk = (high << 12) | low;
		bytes.push(chunk & 0xff);
		bytes.push((chunk >> 8) & 0xff);
		bytes.push((chunk >> 16) & 0xff);
	}
	if (suffix.length) {
		for (const byte of suffix) {
			bytes.push(byte & 0xff);
		}
	}
	const out = new Uint8Array(bytes);
	if (isString) {
		return { isString: true, text: leb128Decode(out), bytes: out };
	}
	return { isString: false, text: "", bytes: out };
}

function bytesToHex(bytes) {
	if (!bytes.length) {
		return "";
	}
	const parts = [];
	for (const byte of bytes) {
		parts.push(byte.toString(16).padStart(2, "0"));
	}
	return parts.join(" ");
}

function formatBytes(size) {
	if (size === 0) {
		return "0 bytes";
	}
	const units = ["bytes", "KB", "MB", "GB", "TB"];
	const idx = Math.min(units.length - 1, Math.floor(Math.log(size) / Math.log(1024)));
	const value = size / Math.pow(1024, idx);
	const formatted = idx === 0 || value >= 10 ? Math.round(value) : value.toFixed(1);
	return `${formatted} ${units[idx]}`;
}

function isPrintableAscii(byte) {
	return (byte >= 0x20 && byte <= 0x7e) || byte === 0x09 || byte === 0x0a || byte === 0x0d;
}

function detectFileMetadata(bytes) {
	const length = bytes.length;
	const startsWith = signature => signature.every((value, index) => index < length && bytes[index] === value);
	if (!length) {
		return { mime: "application/octet-stream", extension: "", description: "Empty file" };
	}
	if (startsWith([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a])) {
		return { mime: "image/png", extension: "png", description: "PNG image" };
	}
	if (startsWith([0xff, 0xd8, 0xff])) {
		return { mime: "image/jpeg", extension: "jpg", description: "JPEG image" };
	}
	if (startsWith([0x47, 0x49, 0x46, 0x38, 0x37, 0x61]) || startsWith([0x47, 0x49, 0x46, 0x38, 0x39, 0x61])) {
		return { mime: "image/gif", extension: "gif", description: "GIF image" };
	}
	if (startsWith([0x49, 0x49, 0x2a, 0x00]) || startsWith([0x4d, 0x4d, 0x00, 0x2a]) || startsWith([0x49, 0x49, 0x2b, 0x00]) || startsWith([0x4d, 0x4d, 0x00, 0x2b])) {
		return { mime: "image/tiff", extension: "tiff", description: "TIFF image" };
	}
	if (startsWith([0x25, 0x50, 0x44, 0x46, 0x2d])) {
		return { mime: "application/pdf", extension: "pdf", description: "PDF document" };
	}
	if (startsWith([0x50, 0x4b, 0x03, 0x04])) {
		return { mime: "application/zip", extension: "zip", description: "ZIP archive" };
	}
	if (startsWith([0x1f, 0x8b, 0x08])) {
		return { mime: "application/gzip", extension: "gz", description: "GZIP archive" };
	}
	if (startsWith([0x42, 0x4d])) {
		return { mime: "image/bmp", extension: "bmp", description: "BMP image" };
	}
	if (startsWith([0x00, 0x00, 0x01, 0x00])) {
		return { mime: "image/x-icon", extension: "ico", description: "ICO image" };
	}
	if (startsWith([0x52, 0x49, 0x46, 0x46]) && length >= 12 && bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50) {
		return { mime: "image/webp", extension: "webp", description: "WebP image" };
	}
	if (startsWith([0x52, 0x49, 0x46, 0x46]) && length >= 12 && bytes[8] === 0x57 && bytes[9] === 0x41 && bytes[10] === 0x56 && bytes[11] === 0x45) {
		return { mime: "audio/wav", extension: "wav", description: "WAV audio" };
	}
	if (startsWith([0x4f, 0x67, 0x67, 0x53])) {
		return { mime: "application/ogg", extension: "ogg", description: "Ogg container" };
	}
	if (length >= 12 && bytes[4] === 0x66 && bytes[5] === 0x74 && bytes[6] === 0x79 && bytes[7] === 0x70) {
		const brand = String.fromCharCode(bytes[8], bytes[9], bytes[10], bytes[11]).toLowerCase();
		if (brand === "avif" || brand === "avis") {
			return { mime: "image/avif", extension: "avif", description: "AVIF image" };
		}
		if (brand === "heic" || brand === "heix" || brand === "hevc" || brand === "hevx") {
			return { mime: "image/heic", extension: "heic", description: "HEIC image" };
		}
		if (brand === "mif1" || brand === "msf1") {
			return { mime: "image/heif", extension: "heif", description: "HEIF image" };
		}
	}
	if (startsWith([0x3c, 0x73, 0x76, 0x67])) {
		return { mime: "image/svg+xml", extension: "svg", description: "SVG image" };
	}
	if (startsWith([0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70]) || startsWith([0x00, 0x00, 0x00, 0x14, 0x66, 0x74, 0x79, 0x70])) {
		return { mime: "video/mp4", extension: "mp4", description: "MP4 video" };
	}
	if (startsWith([0x7b, 0x5c, 0x72, 0x74, 0x66])) {
		return { mime: "application/rtf", extension: "rtf", description: "RTF document" };
	}
	if (startsWith([0x3c, 0x3f, 0x78, 0x6d, 0x6c])) {
		return { mime: "application/xml", extension: "xml", description: "XML document" };
	}
	if (startsWith([0x3c, 0x3f, 0x78, 0x6d, 0x6c])) {
		return { mime: "application/xml", extension: "xml", description: "XML document" };
	}
	if (startsWith([0xef, 0xbb, 0xbf])) {
		return { mime: "text/plain", extension: "txt", description: "UTF-8 text" };
	}
	const sampleLength = Math.min(512, length);
	let printable = 0;
	for (let i = 0; i < sampleLength; i += 1) {
		if (isPrintableAscii(bytes[i])) {
			printable += 1;
		}
	}
	if (printable / sampleLength > 0.85) {
		const firstChar = String.fromCharCode(bytes[0]).trim().toLowerCase();
		if (firstChar === "{" || firstChar === "[") {
			return { mime: "application/json", extension: "json", description: "JSON data" };
		}
		if (String.fromCharCode(bytes[0]) === "<") {
			return { mime: "text/html", extension: "html", description: "HTML document" };
		}
		return { mime: "text/plain", extension: "txt", description: "Text file" };
	}
	return { mime: "application/octet-stream", extension: "bin", description: "Binary data" };
}

function isInvisicodeCodepoint(cp) {
	return cp >= BASE && cp < BASE + RANGE;
}

function detectInvisicodeSegments(text) {
	const codepoints = Array.from(text, char => char.codePointAt(0));
	const segments = [];
	for (let i = 0; i < codepoints.length;) {
		const cp = codepoints[i];
		if (cp === STRING_PREFIX && i + 1 < codepoints.length && isInvisicodeCodepoint(codepoints[i + 1])) {
			const start = i;
			i += 1;
			while (i < codepoints.length && isInvisicodeCodepoint(codepoints[i])) {
				i += 1;
			}
			segments.push({ start, end: i });
			continue;
		}
		if (isInvisicodeCodepoint(cp)) {
			const start = i;
			while (i < codepoints.length && isInvisicodeCodepoint(codepoints[i])) {
				i += 1;
			}
			segments.push({ start, end: i });
			continue;
		}
		i += 1;
	}
	return { segments, codepoints };
}

function buildStringFromCodepoints(codepoints, start, end) {
	const chars = [];
	for (let i = start; i < end; i += 1) {
		chars.push(String.fromCodePoint(codepoints[i]));
	}
	return chars.join("");
}

function escapeHTML(str) {
	return str.replace(/[&<>"']/g, ch => ({
		"&": "&amp;",
		"<": "&lt;",
		">": "&gt;",
		"\"": "&quot;",
		"'": "&#39;"
	})[ch] || ch);
}

function showMessage(text, isError) {
	const box = document.getElementById("status");
	if (!text) {
		box.hidden = true;
		return;
	}
	box.hidden = false;
	box.textContent = text;
	box.classList.toggle("error", Boolean(isError));
}

function showSummary(html) {
	document.getElementById("summary").innerHTML = html;
}

(function main() {
	const plainMode = document.getElementById("plain-mode");
	const plainInput = document.getElementById("plain-input");
	const plainFile = document.getElementById("plain-file");
	const plainTextLabel = document.getElementById("plain-text-label");
	const plainFileLabel = document.getElementById("plain-file-label");
	const fileInfo = document.getElementById("file-info");
	const encodedOutput = document.getElementById("encoded-output");
	const copyBtn = document.getElementById("copy-btn");
	const downloadBtn = document.getElementById("download-btn");
	const downloadInfo = document.getElementById("download-info");
	const imagePreviewWrapper = document.getElementById("image-preview-wrapper");
	const imagePreview = document.getElementById("image-preview");
	let pendingDownloadUrl = null;
	let lastDecodedBytes = null;
	let lastDecodedMeta = null;
	let imagePreviewUrl = null;

	function revokeDownloadUrl() {
		if (pendingDownloadUrl) {
			URL.revokeObjectURL(pendingDownloadUrl);
			pendingDownloadUrl = null;
		}
	}

	function revokePreviewUrl() {
		if (imagePreviewUrl) {
			URL.revokeObjectURL(imagePreviewUrl);
			imagePreviewUrl = null;
		}
	}

	function clearImagePreview() {
		revokePreviewUrl();
		imagePreview.removeAttribute("src");
		imagePreview.alt = "Image preview";
		imagePreviewWrapper.classList.add("hidden");
	}

	function showImagePreviewFromBlob(blob, label = "Image preview") {
		revokePreviewUrl();
		imagePreviewUrl = URL.createObjectURL(blob);
		imagePreview.src = imagePreviewUrl;
		imagePreview.alt = label;
		imagePreviewWrapper.classList.remove("hidden");
	}

	function showImagePreviewFromBytes(bytes, meta) {
		try {
			const blob = new Blob([bytes], { type: meta.mime || "application/octet-stream" });
			const label = meta && meta.description ? meta.description : "Decoded image";
			showImagePreviewFromBlob(blob, label);
		} catch (err) {
			clearImagePreview();
		}
	}

	function resetDownloadState(message = "No decoded file available.", preservePreview = false) {
		revokeDownloadUrl();
		lastDecodedBytes = null;
		lastDecodedMeta = null;
		downloadBtn.disabled = true;
		downloadInfo.textContent = message;
		if (!preservePreview) {
			clearImagePreview();
		}
	}

	function prepareDownload(bytes, meta) {
		revokeDownloadUrl();
		lastDecodedBytes = bytes;
		lastDecodedMeta = meta;
		if (!bytes.length) {
			downloadBtn.disabled = true;
			downloadInfo.textContent = "Decoded file is empty.";
			clearImagePreview();
			return;
		}
		downloadBtn.disabled = false;
		const mimeNote = meta.mime ? `, ${meta.mime}` : "";
		downloadInfo.textContent = `Ready: ${meta.description} (${formatBytes(bytes.length)}${mimeNote}).`;
		if (meta.mime && meta.mime.startsWith("image/")) {
			showImagePreviewFromBytes(bytes, meta);
		} else {
			clearImagePreview();
		}
	}

	function syncInputMode() {
		const useText = plainMode.value === "text";
		plainInput.classList.toggle("hidden", !useText);
		plainTextLabel.classList.toggle("hidden", !useText);
		plainFile.classList.toggle("hidden", useText);
		plainFileLabel.classList.toggle("hidden", useText);
		fileInfo.classList.toggle("hidden", useText);
		if (useText) {
			fileInfo.textContent = "No file selected.";
			clearImagePreview();
		}
	}

	async function handleEncode() {
		try {
			let raw;
			let summaryInfo = "";
			if (plainMode.value === "text") {
				raw = plainInput.value;
				summaryInfo = `Encoded string (${Array.from(raw).length} chars)`;
			} else {
				const file = plainFile.files[0];
				if (!file) {
					throw new Error("Select a file to encode.");
				}
				const buffer = await file.arrayBuffer();
				raw = new Uint8Array(buffer);
				summaryInfo = `Encoded file ${escapeHTML(file.name || "(unnamed)")} (${formatBytes(raw.length)})`;
			}
			const encoded = plainMode.value === "text" ?
				encodeInvisicode(raw, true) :
				encodeInvisicode(raw, false);
			encodedOutput.value = encoded;
			const visibleLength = Array.from(encoded).length;
			summaryInfo += ` → ${visibleLength} invisicode glyphs.`;
			showMessage("Encoding succeeded.", false);
			showSummary(summaryInfo);
		} catch (err) {
			showMessage(err.message, true);
			showSummary("");
		}
	}

	document.getElementById("encode-btn").addEventListener("click", () => {
		handleEncode();
	});
	document.getElementById("decode-btn").addEventListener("click", () => {
		try {
			const payload = encodedOutput.value;
			const { segments, codepoints } = detectInvisicodeSegments(payload);
			if (!segments.length) {
				const decoded = decodeInvisicode(payload);
				if (decoded.isString) {
					plainMode.value = "text";
					syncInputMode();
					plainInput.value = decoded.text;
					const charCount = Array.from(decoded.text).length;
					showSummary(`Detected invisicode string → ${charCount} decoded characters.`);
					resetDownloadState();
				} else {
					plainMode.value = "file";
					syncInputMode();
					fileInfo.textContent = "Decoded output ready for download.";
					const meta = detectFileMetadata(decoded.bytes);
					prepareDownload(decoded.bytes, meta);
					const detail = meta.extension ? `${meta.description} (${meta.extension})` : meta.description;
					showSummary(`Decoded invisicode bytes → ${decoded.bytes.length} bytes (${detail}).`);
				}
				showMessage("Decoding succeeded.", false);
				return;
			}
			const results = segments.map(segment => {
				const fragment = buildStringFromCodepoints(codepoints, segment.start, segment.end);
				return { segment, decoded: decodeInvisicode(fragment) };
			});
			const primary = results[0];
			const coversEntireInput = segments.length === 1 && segments[0].start === 0 && segments[0].end === codepoints.length;
			if (coversEntireInput) {
				if (primary.decoded.isString) {
					plainMode.value = "text";
					syncInputMode();
					plainInput.value = primary.decoded.text;
					const charCount = Array.from(primary.decoded.text).length;
					showSummary(`Detected invisicode string → ${charCount} decoded characters.`);
					resetDownloadState();
				} else {
					plainMode.value = "file";
					syncInputMode();
					fileInfo.textContent = "Decoded output ready for download.";
					const meta = detectFileMetadata(primary.decoded.bytes);
					prepareDownload(primary.decoded.bytes, meta);
					const detail = meta.extension ? `${meta.description} (${meta.extension})` : meta.description;
					showSummary(`Decoded invisicode bytes → ${primary.decoded.bytes.length} bytes (${detail}).`);
				}
				showMessage("Decoding succeeded.", false);
				return;
			}
			if (primary.decoded.isString) {
				plainMode.value = "text";
				syncInputMode();
				plainInput.value = primary.decoded.text;
				resetDownloadState();
			} else {
				plainMode.value = "file";
				syncInputMode();
				fileInfo.textContent = "Primary segment ready for download.";
				const meta = detectFileMetadata(primary.decoded.bytes);
				prepareDownload(primary.decoded.bytes, meta);
			}
			const listItems = results.map((res, index) => {
				const { segment, decoded } = res;
				const rangeLabel = `chars ${segment.start}–${segment.end - 1}`;
				if (decoded.isString) {
					const glyphs = Array.from(decoded.text);
					const charCount = glyphs.length;
					const previewGlyphs = glyphs.slice(0, 1024);
					let preview = escapeHTML(previewGlyphs.join(""));
					if (previewGlyphs.length < glyphs.length) {
						preview += " ...";
					}
					return `<li>Segment ${index + 1} (${rangeLabel}): string (${charCount} chars)${preview ? ` — <code>${preview}</code>` : ""}</li>`;
				}
				const bytes = decoded.bytes;
				const byteCount = bytes.length;
				let preview = "";
				if (byteCount) {
					const sample = bytes.slice(0, 256);
					preview = bytesToHex(sample);
					if (byteCount > 256) {
						preview += " ...";
					}
				}
				const meta = detectFileMetadata(bytes);
				const detail = meta.extension ? `${meta.description} (${meta.extension})` : meta.description;
				const detailHtml = detail ? ` <span>(${escapeHTML(detail)})</span>` : "";
				return `<li>Segment ${index + 1} (${rangeLabel}): bytes (${byteCount} bytes)${preview ? ` — <code>${escapeHTML(preview)}</code>` : ""}${detailHtml}</li>`;
			}).join("");
			showSummary(`<p>Detected ${segments.length} invisicode segment${segments.length === 1 ? "" : "s"} inside the text. First result populated below.</p><ul>${listItems}</ul>`);
			showMessage("Decoding succeeded.", false);
		} catch (err) {
			const preservePreview = plainMode.value === "file" && plainFile.files.length > 0;
			resetDownloadState("No decoded file available.", preservePreview);
			showMessage(err.message, true);
			showSummary("");
		}
	});
	plainMode.addEventListener("change", () => {
		if (plainMode.value !== "text") {
			plainInput.value = "";
		}
		plainFile.value = "";
		syncInputMode();
		resetDownloadState();
		showSummary("");
		showMessage("", false);
	});
	plainFile.addEventListener("change", () => {
		if (!plainFile.files.length) {
			fileInfo.textContent = "No file selected.";
			resetDownloadState();
			return;
		}
		const file = plainFile.files[0];
		fileInfo.textContent = `${file.name || "(unnamed)"} — ${formatBytes(file.size)}`;
		const mime = (file.type || "").toLowerCase();
		const name = file.name || "";
		const isPreviewable = mime.startsWith("image/") || /\.(?:png|jpe?g|gif|bmp|webp|avif|heic|heif|tiff?|ico)$/i.test(name);
		if (isPreviewable) {
			showImagePreviewFromBlob(file, name ? `Preview of ${name}` : "Selected image");
		} else {
			clearImagePreview();
		}
		resetDownloadState("No decoded file available.", true);
	});
	copyBtn.addEventListener("click", async () => {
		const payload = encodedOutput.value;
		if (!payload) {
			showMessage("Nothing to copy.", true);
			return;
		}
		try {
			if (navigator.clipboard && navigator.clipboard.writeText) {
				await navigator.clipboard.writeText(payload);
			} else {
				const helper = document.createElement("textarea");
				helper.value = payload;
				helper.setAttribute("readonly", "");
				helper.style.position = "absolute";
				helper.style.left = "-9999px";
				document.body.appendChild(helper);
				helper.select();
				document.execCommand("copy");
				document.body.removeChild(helper);
			}
			showMessage("Payload copied to clipboard.", false);
		} catch (err) {
			showMessage(`Copy failed: ${err.message}`, true);
		}
	});
	downloadBtn.addEventListener("click", () => {
		if (!lastDecodedBytes || !lastDecodedBytes.length) {
			showMessage("Decoded file is empty or unavailable.", true);
			return;
		}
		try {
			const meta = lastDecodedMeta || { mime: "application/octet-stream", extension: "bin" };
			const blob = new Blob([lastDecodedBytes], { type: meta.mime || "application/octet-stream" });
			pendingDownloadUrl = URL.createObjectURL(blob);
			const link = document.createElement("a");
			const suffix = meta.extension ? `.${meta.extension}` : "";
			link.download = `decoded${suffix}`;
			link.href = pendingDownloadUrl;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			setTimeout(() => revokeDownloadUrl(), 0);
			showMessage("Download started.", false);
		} catch (err) {
			showMessage(`Download failed: ${err.message}`, true);
		}
	});

	syncInputMode();
	resetDownloadState();
})();
</script>
</body>
</html>
