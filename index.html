<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Invisicode Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
	color-scheme: light dark;
	font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
	background: #f5f5f5;
	color: #222;
}
body {
	margin: 0;
	min-height: 100vh;
	display: flex;
	flex-direction: column;
}
main {
	flex: 1;
	padding: 1.5rem;
	max-width: 960px;
	margin: 0 auto;
}
h1 {
	font-size: 1.9rem;
	margin: 0 0 0.75rem;
}
p.intro {
	margin: 0 0 1.5rem;
	max-width: 720px;
}
.controls {
	display: grid;
	gap: 1.5rem;
	grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}
.panel {
	background: rgba(255, 255, 255, 0.8);
	border: 1px solid #d0d0d0;
	border-radius: 12px;
	padding: 1rem;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
}
.panel h2 {
	font-size: 1.2rem;
	margin: 0 0 0.5rem;
}
label {
	display: block;
	font-weight: 600;
	margin-bottom: 0.5rem;
}
select, textarea, button {
	width: 100%;
	box-sizing: border-box;
	font: inherit;
}
textarea {
	min-height: 180px;
	padding: 0.75rem;
	border-radius: 8px;
	border: 1px solid #c0c0c0;
	resize: vertical;
}
button {
	margin-top: 0.75rem;
	padding: 0.6rem 0.8rem;
	border-radius: 8px;
	border: none;
	background: #1f7aec;
	color: #fff;
	cursor: pointer;
	font-weight: 600;
}
button:disabled {
	background: #a0a0a0;
	cursor: not-allowed;
}
.status {
	margin-top: 1.25rem;
	padding: 0.75rem 1rem;
	border-radius: 8px;
	background: rgba(0, 128, 0, 0.08);
	border: 1px solid rgba(0, 128, 0, 0.2);
}
.status.error {
	background: rgba(196, 24, 24, 0.08);
	border-color: rgba(196, 24, 24, 0.4);
	color: #a00000;
}
.summary {
	margin-top: 0.75rem;
	font-size: 0.95rem;
	line-height: 1.5;
}
@media (prefers-color-scheme: dark) {
	:root {
		background: #111;
		color: #f5f5f5;
	}
	.panel {
		background: rgba(24, 24, 24, 0.8);
		border-color: #2f2f2f;
	}
	textarea {
		border-color: #333;
		background: #1c1c1c;
		color: inherit;
	}
	.status {
		background: rgba(56, 142, 60, 0.18);
		border-color: rgba(76, 175, 80, 0.45);
	}
	.status.error {
		background: rgba(244, 67, 54, 0.15);
		border-color: rgba(229, 57, 53, 0.45);
	}
}
</style>
</head>
<body>
<main>
	<h1>Invisicode Playground</h1>
	<p class="intro">Paste text or hex bytes on the left and generate an invisible Unicode payload, or drop invisicode text on the right to recover the original data. The JavaScript below was generated by GPT-5-Codex, and mirrors the <a href="https://github.com/thomas-xin/invisicode">invisicode</a> reference implementation.</p>
	<div class="controls">
		<section class="panel">
			<h2>Plain Data</h2>
			<label for="plain-mode">Input mode</label>
			<select id="plain-mode">
				<option value="text">Text (LEB128 wrapped)</option>
				<option value="hex">Hex bytes</option>
			</select>
			<label for="plain-input">Content</label>
			<textarea id="plain-input" placeholder="Hello World! ❤️"></textarea>
			<button id="encode-btn" type="button">Encode →</button>
		</section>
		<section class="panel">
			<h2>Invisicode String</h2>
			<label for="encoded-output">Payload (invisible characters)</label>
			<textarea id="encoded-output" placeholder="Output appears blank but contains high-plane characters."></textarea>
			<button id="decode-btn" type="button">← Decode</button>
			<button id="copy-btn" type="button">Copy Payload</button>
		</section>
	</div>
	<div id="status" class="status" hidden>Ready.</div>
	<div id="summary" class="summary"></div>
</main>
<script>
const BASE = 0xe0000;
const RANGE = 0x1000;
const STRING_PREFIX = 0x1d17a;
const PADDING = BASE + RANGE - 1;

function leb128Encode(str) {
	if (!str) {
		return new Uint8Array(0);
	}
	const bytes = [];
	for (const char of str) {
		const code = char.codePointAt(0);
		if (code < 0x80) {
			bytes.push(code);
		} else if (code < 0x4000) {
			bytes.push((code & 0x7f) | 0x80);
			bytes.push((code >> 7) & 0x7f);
		} else {
			bytes.push((code & 0x7f) | 0x80);
			bytes.push(((code >> 7) & 0x7f) | 0x80);
			bytes.push(code >> 14);
		}
	}
	return new Uint8Array(bytes);
}

function leb128Decode(bytes) {
	const codepoints = [];
	for (let i = 0; i < bytes.length;) {
		const first = bytes[i++];
		if ((first & 0x80) === 0) {
			codepoints.push(first);
			continue;
		}
		if (i >= bytes.length) {
			throw new Error("Incomplete LEB128 sequence.");
		}
		const second = bytes[i++];
		if ((second & 0x80) === 0) {
			const cp = (first & 0x7f) | (second << 7);
			codepoints.push(cp);
			continue;
		}
		if (i >= bytes.length) {
			throw new Error("Incomplete LEB128 sequence.");
		}
		const third = bytes[i++];
		const cp = (first & 0x7f) | ((second & 0x7f) << 7) | (third << 14);
		if (cp >= 0x110000) {
			throw new Error("Decoded codepoint is out of range.");
		}
		codepoints.push(cp);
	}
	let result = "";
	for (const cp of codepoints) {
		result += String.fromCodePoint(cp);
	}
	return result;
}

function encodeInvisicode(dataBytes, treatAsString) {
	let payload = dataBytes;
	let prefix = "";
	if (treatAsString) {
		payload = leb128Encode(dataBytes);
		prefix = String.fromCodePoint(STRING_PREFIX);
	}
	const remainder = payload.length % 3;
	const full = payload.length - remainder;
	const pieces = [];
	for (let i = 0; i < full; i += 3) {
		const chunk = payload[i] | (payload[i + 1] << 8) | (payload[i + 2] << 16);
		const low = chunk & (RANGE - 1);
		const high = chunk >>> 12;
		pieces.push(String.fromCodePoint(BASE | low));
		pieces.push(String.fromCodePoint(BASE | high));
	}
	let suffix = "";
	if (remainder === 1) {
		suffix = String.fromCodePoint(BASE | payload[full]);
	} else if (remainder === 2) {
		suffix = String.fromCodePoint(BASE | payload[full]) +
			String.fromCodePoint(BASE | payload[full + 1]) +
			String.fromCodePoint(PADDING);
	}
	return prefix + pieces.join("") + suffix;
}

function decodeInvisicode(text) {
	const codepoints = [];
	for (const char of text) {
		codepoints.push(char.codePointAt(0));
	}
	let isString = false;
	if (codepoints.length && codepoints[0] === STRING_PREFIX) {
		isString = true;
		codepoints.shift();
	}
	while (codepoints.length && (codepoints[codepoints.length - 1] < BASE || codepoints[codepoints.length - 1] >= BASE + RANGE)) {
		codepoints.pop();
	}
	let suffix = [];
	if (codepoints.length % 2 === 1) {
		if (codepoints.length >= 3 && codepoints[codepoints.length - 1] === PADDING) {
			const first = codepoints[codepoints.length - 2];
			const second = codepoints[codepoints.length - 3];
			suffix = [second - BASE, first - BASE];
			codepoints.length -= 3;
		} else {
			const last = codepoints.pop();
			suffix = [last - BASE];
		}
	}
	const bytes = [];
	for (let i = 0; i < codepoints.length; i += 2) {
		const low = codepoints[i] - BASE;
		const high = codepoints[i + 1] - BASE;
		if (low < 0 || low >= RANGE || high < 0 || high >= RANGE) {
			throw new Error("Character outside invisicode range detected.");
		}
		const chunk = (high << 12) | low;
		bytes.push(chunk & 0xff);
		bytes.push((chunk >> 8) & 0xff);
		bytes.push((chunk >> 16) & 0xff);
	}
	if (suffix.length) {
		for (const byte of suffix) {
			bytes.push(byte & 0xff);
		}
	}
	const out = new Uint8Array(bytes);
	if (isString) {
		return { isString: true, text: leb128Decode(out), bytes: out };
	}
	return { isString: false, text: "", bytes: out };
}

function parseHex(input) {
	const clean = input.replace(/[^0-9a-fA-F]/g, "");
	if (!clean.length) {
		return new Uint8Array(0);
	}
	if (clean.length % 2 !== 0) {
		throw new Error("Hex input must contain an even number of digits.");
	}
	const bytes = new Uint8Array(clean.length / 2);
	for (let i = 0; i < clean.length; i += 2) {
		bytes[i / 2] = parseInt(clean.slice(i, i + 2), 16);
	}
	return bytes;
}

function bytesToHex(bytes) {
	if (!bytes.length) {
		return "";
	}
	const parts = [];
	for (const byte of bytes) {
		parts.push(byte.toString(16).padStart(2, "0"));
	}
	return parts.join(" ");
}

function showMessage(text, isError) {
	const box = document.getElementById("status");
	if (!text) {
		box.hidden = true;
		return;
	}
	box.hidden = false;
	box.textContent = text;
	box.classList.toggle("error", Boolean(isError));
}

function showSummary(html) {
	document.getElementById("summary").innerHTML = html;
}

(function main() {
	const plainMode = document.getElementById("plain-mode");
	const plainInput = document.getElementById("plain-input");
	const encodedOutput = document.getElementById("encoded-output");
	const copyBtn = document.getElementById("copy-btn");
	document.getElementById("encode-btn").addEventListener("click", () => {
		try {
			let raw;
			if (plainMode.value === "text") {
				raw = plainInput.value;
			} else {
				raw = parseHex(plainInput.value);
			}
			const encoded = plainMode.value === "text" ?
				encodeInvisicode(raw, true) :
				encodeInvisicode(raw, false);
			encodedOutput.value = encoded;
			const visibleLength = Array.from(encoded).length;
			const info = plainMode.value === "text" ?
				`Encoded string (${plainInput.value.length} chars) → ${visibleLength} invisicode glyphs.` :
				`Encoded ${raw.length} bytes → ${visibleLength} invisicode glyphs.`;
			showMessage("Encoding succeeded.", false);
			showSummary(info);
		} catch (err) {
			showMessage(err.message, true);
			showSummary("");
		}
	});
	document.getElementById("decode-btn").addEventListener("click", () => {
		try {
			let payload = encodedOutput.value;
			if (payload && payload[0] == "X" && payload[payload.length - 1] == "Y") {
				payload = payload.slice(1, -1);
			}
			const decoded = decodeInvisicode(payload);
			if (decoded.isString) {
				plainMode.value = "text";
				plainInput.value = decoded.text;
				const charCount = Array.from(decoded.text).length;
				showSummary(`Detected invisicode string → ${charCount} decoded characters.`);
			} else {
				plainMode.value = "hex";
				plainInput.value = bytesToHex(decoded.bytes);
				showSummary(`Decoded invisicode bytes → ${decoded.bytes.length} bytes.`);
			}
			showMessage("Decoding succeeded.", false);
		} catch (err) {
			showMessage(err.message, true);
			showSummary("");
		}
	});
	plainMode.addEventListener("change", () => {
		showSummary("");
	});
	copyBtn.addEventListener("click", async () => {
		const payload = encodedOutput.value;
		if (!payload) {
			showMessage("Nothing to copy.", true);
			return;
		}
		try {
			if (navigator.clipboard && navigator.clipboard.writeText) {
				await navigator.clipboard.writeText(payload);
			} else {
				const helper = document.createElement("textarea");
				helper.value = payload;
				helper.setAttribute("readonly", "");
				helper.style.position = "absolute";
				helper.style.left = "-9999px";
				document.body.appendChild(helper);
				helper.select();
				document.execCommand("copy");
				document.body.removeChild(helper);
			}
			showMessage("Payload copied to clipboard.", false);
		} catch (err) {
			showMessage(`Copy failed: ${err.message}`, true);
		}
	});
})();
</script>
</body>
</html>
